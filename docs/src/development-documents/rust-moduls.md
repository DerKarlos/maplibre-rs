# Rust soucre-code moduls

This is an overview an the structure of the funcktion-packages and the Rust source-codes.
The "formal" API for the Rust crates are in the Docs, generated by komments in the source-codes.
todo:LINK


Maplibre RS consists of
* the core map renderer, including the GPU-renderer inspired by Bevy
* the user-UI and user-input-controls
* the demo applicatons for the different platforms

## Mab renderer

* lib.rs: The main lib to add in \[dependencies\] in Cargo.toml. Classes: **Map:** interface of the map render. **UninitializedMap:**  Stores the map configuration before the map's state has been fully initialized. **MapBuilder:** TODO
* environment.rs: **trait** with all interfaces?, Map needs
* window.rs: Utilities for the window system: WindowSize, traits for Headed-MapWindow-Config, EventLoop
* schedule.rs: Shhedules the stages of multible "jobs"???
* map_schedule.rs: Stores the state of the map, dispatches tile fetching and caching, tessellation and drawing. (InteractiveMapSchedule:update_and_redraw+resize+, PrematureMapContext, EventuallyMapContext)
* coords.rs: Coordinates: Quadkey(node position in quad tree), ZoomLevel, LatLon, Zoom, InnerCoords, TileCoords, Aligned-WorldTileCoords, WorldCoords, ViewRegion
* context.rs: **ViewState**: Stores the camera configuration. **MapContext**: ViewState, Style, TileRepository, Renderer.
* headless.rs: Extras for headless map rendering: HeadlessMapWindow-Config, HeadlessEnvironment, HeadlessMap-Schedule, CopySurfaceBufferNode, WriteSurfaceBufferStage, HeadlessPipelineProcessor
* error.rs: Obvious
* benchmarking.rs: Obvious

platform/..
* mod.rs  Sets a platform dependend COLOR_TEXTURE_FORMAT for webGL, iOS etc. and other dependend functions

platform/noweb/..   support for native platforms
* mod.rs:   Root function run_multithreaded
* http_client.rs: ReqwestHttpClient(new HttpClient)
* scheduler.rs:  TokioScheduler (for stages??)
* trace.rs: adds a Trace-Test

style/..   Map-Style module
* mod.rs:: Root of the mod style, ingludes style, layer and source. 
* style.rs: Contains the "class" Style::default of the mapstyle
* layer.rs: With the Style of a Layer and enum LayerPaint as BackgroundPaint, Fill- or LinePaint. 
* source.rs: With the tile source/web url, enum TileAddressingScheme (xyz or tms) and  Source (Vector or Raster)

stages/..  Tile load process stages manager ??
* mod.rs: With the "class" HeadedPipelineProcessor and the fn register_stages
* request_stage.rs: RequestStage(new run request_tile request_tiles_in_view) + pub fn schedule
* populate_tile_store_stage.rs: PopulateTileStore(new run)

io/..    All about tile loading? And interpreting??
* mod.rs:  Root for io module and "class" TileRequest
* scheduler.rs:   Async/await scheduler. Can schedule a task from a future factory and a shared state.
* apc.rs:  SchedulerAsyncProcedureCall(new AsyncProcedureCall receive schedule)
* pipeline.rs: Processes events which happen during the pipeline execution
* geometry_index.rs: A quad tree storing the currently loaded tiles.
* source_client.rs: Gives access to the HTTP client which can be of multiple types
* static_tile_fetcher.rs: Load PBF files -?- which were statically embedded in the `build.rs`
* tile_pipelines.rs: ParseTile/TessellateLayer (process)
* tile_repository.rs: Stores multiple StoredLayer - TileRepository(new clear put_tessellated_layer iter_tessellated_layers_at create_tile needs_fetching success fail retain_missing_layer_names is_layers_missing)
* transferables.rs: DefaultTileTessellated(new coords) DefaultUnavailableLayer(new to_stored_layer) DefaultTessellatedLayer(new to_stored_layer)

tessellation/..  (used? todo)
* mod.rs: Main code with classes: VertexConstructor, OverAlignedVertexBuffer
* zero_tessellator.rs: ZeroTessellator

util/..   Utilities 
* mod.rs: MinMaxBoundingBox(new, is_initialized, update)  ChangeObserver(new default did_change)
* fps_meter.rs: Measures the frames per second
* grid.rs: OSM/Tile-Grid-Values, named google_mercator
* label.rs: Macro to define a new label trait
* math.rs: A 3-dimensional plane(new from_point/-normal intersection_distance_ray -points_aabb3 -polygon_aabb3) ++ A wrapper type that enables ordering floats.

-----

This module **render** uses the crate wgpu and contains the render pipeline. Hwo to do a renderer in rust is ... complex :-) A detailed descripton is not of high priority at the moment. But at last the interface should be clarified (todo)

render/..      The renderer, inspired by the Bevy renderer ??
* mod.rs:  This module implements the rendering algorithm of maplibre-rs. It manages the whole communication with the GPU --
Renderer(initialize -_headless resize request_device) -- RenderState(new recreate_/-surface buffer_pool_mut)
* camera.rs: Main camera
* eventually.rs: Wrapper around a resource which can be initialized or uninitialized.
* graph_runner.rs: Executes a `RenderGraph`
* main_pass.rs: The main render pass for this application.
* render_commands.rs: Specifies the instructions which are going to be sent to the GPU.
* settings.rs: Settings for the renderer
* tile_pipeline.rs: Utility for declaring pipelines.
* tile_view_pattern.rs: Utility for generating a tile pattern which can be used for masking.

render/render_phase/..   queue to render OSM-objects? to the 2d canvas?
* mod.rs: RenderPhase(add sort) Collect and sort draw requests for specific `PhaseItems`
* draw.rs: Draw function, used to draw a specific `PhaseItem`

render/graph/..
* mod.rs: render-graph-root: pub use context,edge,graph,node,node_slot.  enum RenderGraphError
* context.rs: The context with all graph information required to run a `Node`.
* edge.rs: An edge, which connects two `Nodes` in a `RenderGraph`.
* graph.rs: The render graph configures the modular, parallel and re-usable render logic.
* node_slot.rs: A value passed between render `Nodes.
* node.rs: The context with all information required to interact with the GPU.

render/resource/..
* mod.rs: Utilities which holds references to GPU-owned. Usually a resource is a wrapper which makes using buffers or textures simpler.
* buffer_pool.rs: A ring-buffer like pool of for vertex,indices,feature metadata,ayer metadata.
* globals.rs: A bind group which binds a buffer with global data like the current camera transformations.
* pipeline.rs: Utility for creating wgpu::RenderPipelines
* shader.rs: Utilities for creating shader states.
* tracked_render_pass.rs: A render pass which allows tracking, for example using a tracing framework.
* surface.rs: Utilities for handling surfaces which can be either headless or headed. A headed surface has a handle to a window. A headless surface renders to a texture.
* texture.rs: Utility for a texture view which can either be created by a [`TextureView`](wgpu::TextureView) or [`SurfaceTexture`](wgpu::SurfaceTexture)

render/shaders/..  
* mod.rs: Vec2/3/4f32 Mat4x4f32, TileMaskShader/TileShader(Shader) ShaderCamera/-Globals/-Vertex/-FeatureStyle/-Layer/-TileMetadata
* tile_mask.fragment.wgsl tile_mask.vertex.wgsl tile.fragment.wgsl tile.vertex.wgsl:  GPU-Shader (2D??)

render/stages/..
* mod.rs: The labels of the default App rendering stages = RenderStageLabel(Prepare,Queue,PhaseSort,Render,Cleanup) -- multi_stage!(prepare,resource,extract,upload)
* resource_stage.rs: Prepares GPU-owned resources by initializing them if they are uninitialized or out-of-date.
* extract_stage.rs:  Extracts data from the current state.
* upload_stage.rs: Uploads data to the GPU which is needed for rendering.
* queue_stage.rs: Queues `PhaseItems`(crate::render::render_phase::PhaseItem) for rendering.
* phase_sort_stage.rs: Sorts items of the `RenderPhases`(RenderPhase).
* graph_runner_stage.rs: Executes the `RenderGraph` current render graph.


### User UI and input control

maplibre-winit/..
* lib.rs:  mablibre-winit lib, including functions winit and inputs

maplibre-wini/winit/...  Window handler
* mod.rs: receiving window events and call of the input handler (maplibre-wini/input/mod.rs) and the map renderer
* noweb.rs: Event loop for desktop platforms
* web.rs: Event loop for Web-Application
(Mobile devices ??)

maplibre-wini/input/...  Input handler  User UI for kamera view
* mod.rs: root of the input control, calls the following handlers:
* shift_handler.rs: Keyboard panning
* pan_handler.rs: Touch panning
* pinch_handler.rs: Touch zooming (still empty)
* query_handler.rs: Touch and Mouse klicking = down & up without move
* tilt_handler.rs: Keyboard camera rotating, only pitching = view up/down
* zoom_handler.rs: Keyboard and Mouse-scroll zooming


### Demo applicatons

Building the different platforms is desctiptet in:
[How to Run Demos](./development-guide/how-to-run.md) and 
[Library Packaging](./development-documents/library-packaging.md)

#### Desktop application

maplibre-demo/.. 
* main.rs: The main shell applicatoin is taking `parameters`(todo) and will opening a window. Or it will call the headless modul to write a bitmap.
* headless.rs: Renders the map into a offline canvas and writes a bitmap file


#### Web application (web/..)
The Rust crate(s) are build as WASM modul with JS clue-code and a HTML (Interface ???)
demo/..  ??
lib/..   ??

#### Apple (mobild AND desktop???)

#### Android app (android/..)

? The Rust crate(s?) are build as WASM modul and used by an android cradle(java wrapper?) ?


## Build Tools

TODO?

## Benchmaks

TODO?
